name: Publish jq images
on:
  push:
    tags:
      - 'jq-*'
env:
  DOCKER_REPO: diafour/jq
  PLATFORMS: "linux/amd64,linux/arm64/v8,linux/arm/v7"

jobs:
  extract_multiarch_assets:
    name: Check tag format
    runs-on: [ubuntu-latest]
    steps:
      - uses: actions/checkout@v2

#      - name: Set up QEMU
#        uses: docker/setup-qemu-action@v1
#        with:
#          platforms: "arm64,arm"

      - name: Set up Docker Buildx
        id: buildx
        uses: docker/setup-buildx-action@v1
        with:
          version: latest

      - name: Extract assets from multiarch image
        run: |
          sudo apt-get install -y file jq

          cat /etc/docker/daemon.json

          echo "Enable Docker experimental features"
          sudo rm -rf /etc/docker/daemon.json
          echo '{"experimental": true}' | sudo tee -a /etc/docker/daemon.json
          sudo systemctl restart docker


          manifest=${{ matrix.flavour }}.manifest
          docker manifest inspect --verbose $FINAL_IMAGE_NAME > ./$manifest
          echo "::group::Manifest inspect"
          cat ./$manifest
          echo "::endgroup::"

          for platform in $(echo $PLATFORMS | sed 's/,/\ /g' ) ; do
            echo "Platform $platform"
            ref=$(cat ./$manifest | jq --arg platform $platform 'map(select(.Descriptor.platform| [.os,.architecture,.variant]| map(select(.))| join("/") == $platform )) | .[0].Ref // ""'
            echo "::group::Extract '${{matrix.flavour}}' assets for '$platform' platform"
            suffix=$(echo $platform | sed 's/\//-/')
            ./scripts/jq-build/extract-file.sh $ref /bin/busybox ./busybox-$suffix
            file ./busybox-$suffix
            echo "::endgroup::"
          done

      - name: Stop
        run: |
          exit 1


  check_tag_format:
    name: Check tag format
    needs: extract_multiarch_assets
    runs-on: [ubuntu-latest]
    steps:
      - uses: actions/checkout@v2

      - name: Check tag format
        uses: actions/github-script@v3
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            const script = require(`${process.env.GITHUB_WORKSPACE}/scripts/jq-build/prepare.js`)
            script.checkTagFormat(github, context, core)

  release_jq_images:
    name: Release jq images
    needs: check_tag_format
    strategy:
      fail-fast: false
      matrix:
        flavour:
          - ubuntu
          - alpine
    runs-on: [ubuntu-latest]
    steps:
      - uses: actions/checkout@v2

      - name: Prepare build env
        uses: actions/github-script@v3
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            // Prepare JQ_GIT_SHA and DOCKER_TAG envs
            const script = require(`${process.env.GITHUB_WORKSPACE}/scripts/jq-build/prepare.js`)
            return script.prepareEnvsForBuild(github, context, core)

      - name: Build '${{ matrix.flavour }}' jq image
        run: |
          FINAL_IMAGE_NAME=$DOCKER_REPO:${DOCKER_TAG}-${{matrix.flavour}}
          echo FINAL_IMAGE_NAME=$FINAL_IMAGE_NAME
          echo "FINAL_IMAGE_NAME=${FINAL_IMAGE_NAME}" >> $GITHUB_ENV

          DOCKERFILE=Dockerfile-${{ matrix.flavour }}

          cd ${GITHUB_WORKSPACE}/scripts/jq-build
          docker build . --build-arg JQ_GIT_SHA=$JQ_GIT_SHA -t $FINAL_IMAGE_NAME -f $DOCKERFILE

      - name: Login to DockerHub
        uses: docker/login-action@v1
        with:
          username: ${{ secrets.DOCKER_USER }}
          password: ${{ secrets.DOCKER_PASS }}

      - name: Push '${{ matrix.flavour }}' image
        run: |
          echo Push "'$FINAL_IMAGE_NAME'"
          docker push $FINAL_IMAGE_NAME

      - name: Extract '${{ matrix.flavour }}' assets
        run: |
          apt-get install -y file jq

          manifest=${{ matrix.flavour }}.manifest
          docker manifest inspect --verbose $FINAL_IMAGE_NAME > ./$manifest

          for platform in $(echo $PLATFORMS | sed 's/,/\ /g' ) ; do
            ref=$(jq --arg platform $platform 'map(select(.Descriptor.platform| [.os,.architecture,.variant]| map(select(.))| join("/") == $platform )) | .[0].Ref // ""'
            echo "::group::Extract '${{matrix.flavour}}' assets for '$platform' platform"
            suffix=$(echo $platform | sed 's/\//-/')
            ./scripts/jq-build/extract-file.sh $ref /bin/busybox ./busybox-$suffix
            file ./busybox-$suffix
            echo "::endgroup::"
          done

          # Get Refs from multiarch
          # jq --arg platforms "linux/amd64,linux/arm64/v8,linux/arm/v7" 'map(select(.Descriptor.platform| [.os,.architecture,.variant]| map(select(.))| join("/") | in($platforms|split(",")|map({"key":., "value":true})|from_entries) ))'

          # Extract all checksum file.
          ALL_CHECKSUM_ARTIFACT=all-${{ matrix.flavour }}.sha
          ./scripts/jq-build/extract-file.sh $FINAL_IMAGE_NAME /all.sha ./$ALL_CHECKSUM_ARTIFACT
          echo "ALL_CHECKSUM_ARTIFACT=$ALL_CHECKSUM_ARTIFACT" >> $GITHUB_ENV

          # Extract libjq checksum file.
          LIBJQ_CHECKSUM_ARTIFACT=libjq-${{ matrix.flavour }}.sha
          ./scripts/jq-build/extract-file.sh $FINAL_IMAGE_NAME /libjq.sha ./$LIBJQ_CHECKSUM_ARTIFACT
          echo "LIBJQ_CHECKSUM_ARTIFACT=$LIBJQ_CHECKSUM_ARTIFACT" >> $GITHUB_ENV

          # Create tgz with libjq.
          mkdir -p ./libjq
          ./scripts/jq-build/extract-libjq.sh $FINAL_IMAGE_NAME ./libjq
          LIBJQ_TGZ_ARTIFACT=libjq-${{ matrix.flavour }}.tgz
          echo "LIBJQ_TGZ_ARTIFACT=$LIBJQ_TGZ_ARTIFACT" >> $GITHUB_ENV
          tar zcf $LIBJQ_TGZ_ARTIFACT libjq

      - name: Get release info
        id: get_release
        uses: actions/github-script@v3
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            const script = require(`${process.env.GITHUB_WORKSPACE}/scripts/jq-build/get-release.js`)
            return await script(github, context, core)

#      - name: release id consumer
#        run: |
#          echo release id is ${{ steps.get_release.outputs.id }}
#          echo release upload_url is  ${{ steps.get_release.outputs.upload_url }}
#          echo result is ${{ steps.get_release.outputs.result }}
#          exit 1
#      - name: Create release
#        id: create_release
#        uses: actions/create-release@v1
#        env:
#          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
#        with:
#          tag_name: ${{ github.ref }}
#          release_name: jq+libjq build ${{ github.ref }}
#          draft: false
#          prerelease: false

      - name: Upload all checksum for '${{ matrix.flavour }}'
        id: upload-all-checksum-asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.get_release.outputs.upload_url }}
          asset_path: ./${{ env.ALL_CHECKSUM_ARTIFACT }}
          asset_name: ${{ env.ALL_CHECKSUM_ARTIFACT }}
          asset_content_type: text/plain

      - name: Upload libjq checksum for '${{ matrix.flavour }}'
        id: upload-checksum-asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.get_release.outputs.upload_url }}
          asset_path: ./${{ env.LIBJQ_CHECKSUM_ARTIFACT }}
          asset_name: ${{ env.LIBJQ_CHECKSUM_ARTIFACT }}
          asset_content_type: text/plain

      - name: Upload libjq archive for '${{ matrix.flavour }}'
        id: upload-libjq-tgz-asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.get_release.outputs.upload_url }}
          asset_path: ./${{ env.LIBJQ_TGZ_ARTIFACT }}
          asset_name: ${{ env.LIBJQ_TGZ_ARTIFACT }}
          asset_content_type: application/gzip

